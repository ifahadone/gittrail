#!/usr/bin/env bash
set -Eeuo pipefail

# gittrail — export commits by a user across GHES repos into CSV
# Developed by Fahad

APP_NAME="gittrail"
APP_VERSION="0.3.0"
APP_DEVELOPER="Fahad"

GH_HOST="${GH_HOST:-github.maybank.com}"
REPO_LIST="${REPO_LIST:-repo-list.csv}"
BRANCH_CACHE_DIR="${BRANCH_CACHE_DIR:-.branches_cache}"
ALL_BRANCHES="${ALL_BRANCHES:-1}"

ORGS="$(printf '%s' "${ORGS:-}" | tr ',' ' ')"  # optional: restrict scan
SINCE="${SINCE:-}"
UNTIL="${UNTIL:-}"
EXCLUDE_FORKS="${EXCLUDE_FORKS:-0}"
EXCLUDE_ARCHIVED="${EXCLUDE_ARCHIVED:-0}"

trap 'printf "%s\n" "fatal: an error occurred. re-run with: bash -x ${APP_NAME} …" >&2' ERR

log(){ printf '%s\n' "$*" >&2; }
need(){ command -v "$1" >/dev/null 2>&1 || { log "Missing: $1"; exit 1; }; }
die(){ log "Error: $*"; exit 1; }

usage(){
  cat <<USAGE
${APP_NAME} ${APP_VERSION} — Developed by ${APP_DEVELOPER}

Usage:
  ${APP_NAME} --reposcan
  ${APP_NAME} --username USER [--out FILE] [--default-branch-only] [--since ISO] [--until ISO]

Required (one of):
  --reposcan                 Rebuild repo cache (repo-list.csv) and exit
  --username USER            GitHub username/login to scan (author & committer)

Optional:
  --out FILE                 Output CSV (default: commits_<USER>.csv)
  --default-branch-only      Scan only default branch (faster)
  --since ISO8601            e.g. 2025-01-01T00:00:00Z
  --until ISO8601            e.g. 2025-09-18T23:59:59Z
  --version                  Show version
  --about                    Show credits

Env (advanced):
  GH_HOST                    GHES host (default: ${GH_HOST})
  ORGS                       Space/comma separated orgs to limit scope
  REPO_LIST                  Repo cache file (default: ${REPO_LIST})
  BRANCH_CACHE_DIR           Branch cache dir (default: ${BRANCH_CACHE_DIR})
  EXCLUDE_FORKS=1            Skip forks
  EXCLUDE_ARCHIVED=1         Skip archived repos
USAGE
}

about(){
  cat <<ABOUT
${APP_NAME} ${APP_VERSION}
Developed by ${APP_DEVELOPER}
Purpose: enumerate GHES repos/branches and export a user's commits (author+committer) to CSV.
ABOUT
}

# ---------- arg parse ----------
USER_LOGIN=""
REPOSCAN=0
OUT=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --reposcan) REPOSCAN=1; shift;;
    --username) USER_LOGIN="${2:-}"; shift 2;;
    --out)      OUT="${2:-}"; shift 2;;
    --default-branch-only) ALL_BRANCHES=0; shift;;
    --since)    SINCE="${2:-}"; shift 2;;
    --until)    UNTIL="${2:-}"; shift 2;;
    --version)  echo "${APP_NAME} ${APP_VERSION} — Developed by ${APP_DEVELOPER}"; exit 0;;
    --about)    about; exit 0;;
    -h|--help)  usage; exit 0;;
    *)          die "Unknown arg: $1";;
  esac
done

need gh; need jq
export GH_HOST

log "${APP_NAME} ${APP_VERSION} — Developed by ${APP_DEVELOPER}"

if ! gh auth status -h "$GH_HOST" >/dev/null 2>&1; then
  die "Not authenticated to $GH_HOST. Run: gh auth login --hostname $GH_HOST"
fi

mkdir -p "$BRANCH_CACHE_DIR"

build_repo_filter(){
  local parts=(".[]")
  [[ "$EXCLUDE_FORKS" -eq 1 ]]    && parts+=("| select(.fork|not)")
  [[ "$EXCLUDE_ARCHIVED" -eq 1 ]] && parts+=("| select(.archived|not)")
  parts+=('| "\(.full_name),\(.default_branch // \"main\")"')
  printf '%s ' "${parts[@]}"
}

ensure_repo_list(){
  local jqf; jqf=$(build_repo_filter)
  printf 'repo,default_branch\n' > "$REPO_LIST"
  if [[ -n "$ORGS" ]]; then
    for org in $ORGS; do
      gh api -X GET --paginate "/orgs/${org}/repos"         -f per_page=100 -f type=all --jq "$jqf" >> "$REPO_LIST"
    done
  else
    gh api -X GET --paginate "/user/repos"       -f per_page=100 -f affiliation=owner,collaborator,organization_member -f visibility=all       --jq "$jqf" >> "$REPO_LIST"
  fi
}

list_branches_cached(){
  local full="$1" def="$2"
  if [[ "$ALL_BRANCHES" -ne 1 ]]; then printf '%s\n' "$def"; return; fi
  local safe="${full//\//__}"
  local cache="$BRANCH_CACHE_DIR/${safe}.txt"
  if [[ -s "$cache" ]]; then cat "$cache"; return; fi
  gh api -X GET --paginate "/repos/${full}/branches" -f per_page=100 --jq '.[].name' > "$cache" || true
  [[ -s "$cache" ]] || printf '%s\n' "$def" > "$cache"
  cat "$cache"
}

fetch_commits(){
  local full="$1" br="$2" role="$3" user="$4"
  local args=(-X GET --paginate "/repos/${full}/commits" -f per_page=100 -f sha="$br" -f "$role=$user")
  [[ -n "$SINCE" ]] && args+=(-f "since=$SINCE")
  [[ -n "$UNTIL" ]] && args+=(-f "until=$UNTIL")
  gh api "${args[@]}"     | jq -c --arg repo "$full" --arg br "$br" '.[] | {repo:$repo, branch:$br, sha:.sha, commit:.commit}'
}

if [[ "$REPOSCAN" -eq 1 ]]; then
  log "Building repo cache -> $REPO_LIST"
  ensure_repo_list
  log "repo-list.csv ready."
  exit 0
fi

[[ -n "$USER_LOGIN" ]] || die "need --username or --reposcan"
[[ -n "$OUT" ]] || OUT="commits_${USER_LOGIN}.csv"

# ensure repo list exists
if [[ ! -s "$REPO_LIST" ]]; then
  log "No $REPO_LIST found — running --reposcan now."
  ensure_repo_list
else
  log "Using cached repo list: $REPO_LIST"
fi

tmp="$(mktemp)"; : > "$tmp"; trap 'rm -f "$tmp"' EXIT

tail -n +2 "$REPO_LIST" | while IFS=',' read -r full default_branch; do
  [[ -z "$full" ]] && continue
  log "Repo: $full"
  while IFS= read -r br; do
    [[ -z "$br" ]] && continue
    log "  Branch: $br"
    fetch_commits "$full" "$br" author    "$USER_LOGIN" >> "$tmp" || true
    fetch_commits "$full" "$br" committer "$USER_LOGIN" >> "$tmp" || true
  done < <(list_branches_cached "$full" "$default_branch")
done

jq -s -r '
  ["repo","branch","sha",
   "authored_date","author_name","author_email",
   "committed_date","committer_name","committer_email",
   "message"],
  ( . | unique_by(.repo + ":" + .sha)
      | sort_by(.repo, .branch, (.commit.author.date // ""))
      | map([
          .repo, .branch, .sha,
          (.commit.author.date // ""),
          (.commit.author.name // ""),
          (.commit.author.email // ""),
          (.commit.committer.date // ""),
          (.commit.committer.name // ""),
          (.commit.committer.email // ""),
          ((.commit.message // "") | gsub("\r\n|\n|\r"; " "))
        ])
      | .[] )
  | @csv
' "$tmp" > "$OUT"

log "Done. Wrote: $OUT"
